/*
  Script: generate-fonts.js
  Purpose: Scan 01_BXYZ_AH_Fonts/ and generate fonts.generated.css with @font-face rules
  Usage:
    node generate-fonts.js
  Notes:
    - Prefers .woff2, includes .woff if present
    - Infers font-family, weight, and style from filename heuristics
*/

const fs = require('fs');
const path = require('path');

const ROOT = __dirname;
const FONTS_DIR = path.join(ROOT, '01_BXYZ_AH_Fonts');
const OUT_FILE = path.join(ROOT, 'fonts.generated.css');

const WEIGHTS = [
  { re: /thin|hairline/i, w: 100 },
  { re: /extralight|ultralight/i, w: 200 },
  { re: /light|demi?light/i, w: 300 },
  { re: /regular|book|normal|roman|text/i, w: 400 },
  { re: /medium|med(?!iumext)/i, w: 500 },
  { re: /semibold|demibold/i, w: 600 },
  { re: /bold/i, w: 700 },
  { re: /extrabold|ultrabold|heavy|black/i, w: 800 },
  { re: /ultraheavy|extrablack|ultrablack|super/i, w: 900 },
];

function detectWeight(name) {
  for (const m of WEIGHTS) if (m.re.test(name)) return m.w;
  return 400;
}

function detectStyle(name) {
  if (/italic|it\b/i.test(name)) return 'italic';
  if (/oblique/i.test(name)) return 'oblique';
  return 'normal';
}

function stripTrailingNumber(base) { return base.replace(/\s+\d+$/, ''); }

function familyFromBase(base) {
  if (base.includes('-')) return base.split('-')[0];
  const tokens = base.split(/[^A-Za-z0-9]+/).filter(Boolean);
  const styleTokens = new Set(['Regular','Book','Text','Thin','Light','Medium','Semi','Semibold','Demi','Demibold','Bold','Extra','Extrabold','Ultra','Ultrabold','Heavy','Black','Italic','Roman']);
  while (tokens.length > 1 && styleTokens.has(tokens[tokens.length-1])) tokens.pop();
  return tokens.join('-') || base;
}

function listFonts() {
  const files = fs.readdirSync(FONTS_DIR)
    .filter(n => ['.woff','.woff2'].includes(path.extname(n).toLowerCase()))
    .filter(n => {
      const p = path.join(FONTS_DIR, n);
      try { return fs.statSync(p).size > 0; } catch { return false; }
    });
  return files.map(n => path.join(FONTS_DIR, n));
}

function key(sig) { return `${sig.family}__${sig.weight}__${sig.style}`; }

function build() {
  if (!fs.existsSync(FONTS_DIR)) throw new Error('Fonts dir not found: ' + FONTS_DIR);
  const files = listFonts();
  const groups = new Map();

  for (const f of files) {
    const ext = path.extname(f).toLowerCase();
    const base = stripTrailingNumber(path.basename(f, ext));
    const sig = {
      family: familyFromBase(base),
      weight: detectWeight(base),
      style: detectStyle(base),
    };
    const k = key(sig);
    if (!groups.has(k)) groups.set(k, { sig, woff2: null, woff: null });
    const g = groups.get(k);
    if (ext === '.woff2') g.woff2 = f;
    if (ext === '.woff') g.woff = f;
  }

  let out = '/* Auto-generated by generate-fonts.js */\n\n';
  for (const { sig, woff2, woff } of groups.values()) {
    if (!woff2 && !woff) continue;
    const urls = [];
    if (woff2) urls.push(`  src: url("./${path.relative(ROOT, woff2)}") format("woff2")`);
    if (woff) {
      const line = `  ${urls.length ? '' : 'src: '}url("./${path.relative(ROOT, woff)}") format("woff")`;
      urls.push(line);
    }
    out += `@font-face {\n`;
    out += `  font-family: "${sig.family}";\n`;
    out += urls.join(',\n') + `;\n`;
    out += `  font-style: ${sig.style};\n`;
    out += `  font-weight: ${sig.weight};\n`;
    out += `  font-display: swap;\n`;
    out += `}\n\n`;
  }

  fs.writeFileSync(OUT_FILE, out, 'utf8');
  console.log(`Wrote ${OUT_FILE} with ${groups.size} @font-face rules.`);
}

build();
